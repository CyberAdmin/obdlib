"""
<Program>
  obdlib.repy 
  
<Date Started>
  June 26th, 2014
	
<Author>
  Mike Reininger
	
<Purpose>
  OBD sensor library for collecting vehicular sensor data.

<Usage/Help>
  OBD-II ELM327 sensors can be used to communicate between a car's controller area network (CAN), also known as the car's electronic brains, and a computer or mobile device. 
  They can be purchased online (suggested model: http://amzn.com/B00AOIM2CC).

  How to connect to the OBD on the Android:
  1. Plug the device into the OBD port under the steering wheel, near the pedals. 
  2. Navigate to your Android's settings --> wireless settings --> connect to wifi router.
  3. Choose WiFi_OBDii. 

  How to run example (obd.r2py) code on Android:
  1. Open the Sensibility app on the Android. Make sure that it has started.
  2. *Modify obd.r2py so that mycontext['OBDIP'] and mycontext['OBDPort'] match with the credentials provided by the OBD sensor's manufacturer. (Note: This can also be done with arguments.)
  3. Run seash and connect to Android.
  4. Upload dylink.repy, sensorlib.repy, obdlib.repy and obd.r2py using seash.
  5. Run: startv2 dylink.repy obd.r2py
  6. Run: show log
  
<TODOs>
  2. Edit usage/help.
  3. Finish '?' error code response for developer, also for return type 'NO DATA'. (ln 106)
  6. Try to make the code run faster. Maybe too many sleeps?
"""



"""
  OBD sensor data retrieval functions.
"""
# Returns speed in KPH, however a KPH --> MPH function is provided below.  
def getSpeed():
  #log("\n[obdlib] Trying speed in kph...")
  return get_obd_data('01 0D')
  
# Since RPM is sent to the Android in increments of 1/4 rpm, we divide the sensor value by 4 to obtain the real RPM.
def getRPM():
  #log("\n[obdlib] Trying RPM...")
  return get_obd_data('01 0C')/4

# Useful for calculating MPG (see task 5)
def getMAF():
  #log("\n[obdlib] Trying MAF...")
  return get_obd_data('01 10')

def getFuelPressure():
  #log("\n[obdlib] Trying fuel pressure...")
  return get_obd_data('01 0A')

def getDistanceTraveledWithMIL():
  #log("\n[obdlib] Trying to calculate the time that the car has been driving with the check engine light on...")
  return get_obd_data('01 0F')

def getBarometricPressure():
  #log("\n[obdlib] Trying barometric pressure...")
  return get_obd_data('01 33')

def getVIN():
  return get_obd_data('09 02')
  
def getThrottlePosition():
  return get_obd_data('01 11') 

def getCurrentLocation():

  request_data(mycontext['sensor_socket'], 'startLocating', [])
  # Loop GPS querying until we get a valid response. The loop will break once SL4A returns a response that should start with {u'network' ... .
  while True:
    try:
      sensor_data = request_data(mycontext['sensor_socket'], 'readLocation', []) 
      if str(sensor_data).startswith("{u'network'"):
        break
    except Exception as e:
      log('\n[obdlib] ',str(e), '\n')
      request_data(mycontext['sensor_socket'], 'stopSensing', []) 
      mycontext['sensor_socket'].close()
      #raise
  return sensor_data

def getFuelConsumption():
  # Use MAF and VSS to calculate the instantaneous fuel consumption rate. This is done through the formula posted here: http://www.lightner.net/lightner/bruce/Lightner-183.pdf
  mpg = (710.7 * getSpeed())/getMAF()
  return mpg

"""
  OBD-II sensor functions.
"""
def get_obd_data(pid):
  # Check if mycontext['OBDIP'] and mycontext['OBDPort'] have been set.
  if(mycontext['OBDIP'] == '' or mycontext['OBDIP'] == None or mycontext['OBDPort'] == '' or mycontext['OBDPort'] == None):
    log('[obdlib] Error: OBDIP or OBDPort not assigned.')
  else:
    cmd = pid[3:5]
    try:
      sleep(1)
      socketobject = openconnection(mycontext['OBDIP'],mycontext['OBDPort'],getmyip(),63157,5000)   
      socketobject.send(pid+'\n')
      # System needs to wait before it closes the socket, or else OBD sensor data never arrives to the phone.
      sleep(3)
      # We should only be reading about 10 bytes.
      data = socketobject.recv(15)
      # Needs to be finished after trimmer function is done.
      if data == '?':
        log('[obdlib] Error: PID not understood by car.')
      elif data == 'NO DATA':
        log('[obdlib] Error: No data provided for specified PID.')
      else:
        return toDecimal(trimmer(data, cmd))
      socketobject.close()
      #return toDecimal(trimmer(data))
    except Exception as e:
      log('\n[obdlib]',str(e),'\n')

# This is used if the developer wants to send a specific PID to the OBD device, perhaps not one listed above...  
def send_obd_command(pid):
  if(mycontext['OBDIP'] == '' or mycontext['OBDIP'] == None or mycontext['OBDPort'] == '' or mycontext['OBDPort'] == None):
    log('[obdlib] Error: OBDIP or OBDPort not assigned.')
  else:

    try:
      socketobject = openconnection(mycontext['OBDIP'],mycontext['OBDPort'],getmyip(),63157,5000)   
      socketobject.send(pid+'\n')
      # System needs to wait before it closes the socket, or else OBD sensor data never arrives to the phone.
      sleep(3)
      data = socketobject.recv(15)
      # Needs improvement (task 4)
      if data == '?':
        log('\n[obdlib] Error: PID not understood by car.')
      elif data == 'NO DATA':
        log('[obdlib] Error: No data provided for specified PID.')
      else:
        log("\n[obdlib] Sent command: ",pid," with response: ",data)
      socketobject.close()
    except Exception as e:
      log('\n[obdlib]',str(e),'\n')

# It is best practice to reset the OBD in case it has been programmed otherwise.  
def resetOBD():
  send_obd_command('AT Z')

# It is also best practice to set the OBD's protocol to automatic, so that this library can communicate with it.
def setAutomaticProtocol():
  send_obd_command('AT SP 0')
  
    
"""
  obdlib.repy added functions.
"""
def trimmer(data, cmd):
  data = data[data.index(cmd)+3:-2]
  data = data.replace(" ","")
  return data
  
def toDecimal(data):
  return int(data, 16)

def toMPH(k):
  return float(k)/1.609344

def setOBDIP(ip):
  mycontext['OBDIP'] = ip

def setOBDPort(port):
  mycontext['OBDPort'] = port   

def setSensorPort(port):
  mycontext['sensor_port'] = port
  mycontext['sensor_socket'] = getconnection(mycontext['sensor_port'])
